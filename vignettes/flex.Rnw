%\VignetteEngine{knitr::knitr}
%\VignetteDepends{ggplot2}
%\VignetteIndexEntry{flexLambda examples}
\documentclass{article}
\newcommand{\code}[1]{{\tt #1}}
\title{\code{flexLmer} examples}
\begin{document}

\section{Setup}

<<pkgs,message=FALSE>>=
library("nlme")
library("lme4")
library("ggplot2"); theme_set(theme_bw())
data(Assay,package="nlme")
@

\section{Examples}

\subsection{Compound symmetry model}

<<ex1>>=
(lmefit1 <- lme(logDens~sample+dilut,
                random=pdCompSymm(~sample-1),
                  Assay))
lmerfit1 <- flexLmer(logDens~sample+dilut+cs(~(0+sample|Block),het=FALSE),
                        as.data.frame(Assay))
summary(lmerfit1)  ## VarCorr output bogus
(tt <- getME(lmerfit1,"theta"))
all.equal(c(logLik(lmerfit1)),c(logLik(lmefit1)))
(ss <- sigma(lmerfit1)) ## residual std. dev.
ss*tt[1]  ## matches among-sample std. dev.
@

\subsection{AR1 model}

This uses Steve Walker's trick from \href{https://github.com/lme4/lme4/issues/224}{Github issue \#224} 

<<gendata,echo=FALSE>>=
simAR1 <- function(nsubj=20,
                   nreps=2,
                   length=20,
                   rho=0.8,sd.b=3,sd.eps=1,beta=0.5,seed=NULL) {
    n <- nsubj*nreps*length
    if (!is.null(seed)) set.seed(seed)
    b <- sd.b * as.vector(replicate(nsubj,
                       arima.sim(n=length, model=list(ar=rho))))
    mu <- with(fr,beta*time)
    y <- with(fr,mu + model.matrix(~0+as.factor(time):id)%*%b + 
                  rnorm(n, sd=sd.eps)
    )
    return(data.frame(mu,y))
}
nsubj <- 20
nreps <- 1
length <- 20
fr <- expand.grid(
    time=1:length,
    id=factor(1:nsubj),
    rep=factor(1:nreps))
## FIXME: rep is a little bit silly when sd.eps=0
fr <- data.frame(fr,simAR1(nsubj,nreps,length,sd.eps=0,seed=2352))
@

<<>>=
qplot(y=mu, x=time, data=fr, geom="line") + facet_wrap(~id) + 
    geom_point(aes(y=y),colour="gray")
@


<<mkVarCorr,echo=FALSE>>=
## Li := \Lambda_i, the i-th block diagonal of \Lambda(\theta)
genLambdatx0 <- function(nc,thl,cnms) {
    Li <- diag(nrow = nc)
    Li[lower.tri(Li, diag = TRUE)] <- thl
    rownames(Li) <- cnms
    Li
}
mkVarCorr <- function(sc,    ## scale factor
                      cnms,  ## named component names
                      nc,    ## vector of number of terms
                      theta, ## theta vector
                      ntheta = nc*(nc+1)/2, 
                      nms=names(cnms),   ##
                      genLambdatx = genLambdatx0) {
    ncseq <- seq_along(nc)
    thl <- split(theta, rep.int(ncseq, ntheta))
    if(!all(nms == names(cnms))) ## the above FIXME
	warning("nms != names(cnms)  -- whereas lme4-authors thought they were --\n",
		"Please report!", immediate. = TRUE)
    Lambdatx <- mapply(genLambdatx0,
                       nc, thl, cnms)
    ## val := \Sigma_i = \sigma^2 \Lambda_i \Lambda_i'
    ans <- lapply(Lambdatx,
                  function(Li) {
                      val <- tcrossprod(sc * Li) # variance-covariance
                      stddev <- sqrt(diag(val))
                      corr <- t(val / stddev)/stddev
                      diag(corr) <- 1
                      structure(val, stddev = stddev, correlation = corr)
                  })
    if(is.character(nms)) {
	## FIXME: do we want this?  Maybe not.
	## Potential problem: the names of the elements of the VarCorr() list
	##  are not necessarily unique (e.g. fm2 from example("lmer") has *two*
	##  Subject terms, so the names are "Subject", "Subject".  The print method
	##  for VarCorrs handles this just fine, but it's a little awkward if we
	##  want to dig out elements of the VarCorr list ... ???
	if (anyDuplicated(nms))
	    nms <- make.names(nms, unique = TRUE)
	names(ans) <- nms
    }
    structure(ans, sc = sc)
}
@

\end{document}
